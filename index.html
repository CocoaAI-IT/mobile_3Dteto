<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Tetris Vertical</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-color: #050510;
            --panel-bg: rgba(20, 20, 35, 0.9);
            --accent-color: #00f3ff;
            --text-color: #e0f7fa;
            --btn-base: #33334d;
            --btn-active: #555570;
            --dpad-size: 60px; /* Size of single d-pad button */
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* --- Header --- */
        #header {
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            z-index: 10;
            position: absolute;
            top: 0;
            width: 100%;
            box-sizing: border-box;
            pointer-events: none;
        }

        .info-box {
            background: rgba(0, 20, 40, 0.6);
            padding: 5px 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 243, 255, 0.3);
            text-align: center;
            pointer-events: auto;
            min-width: 50px;
            backdrop-filter: blur(4px);
        }

        .label { font-size: 10px; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        .value { font-size: 20px; font-weight: bold; color: var(--accent-color); font-family: monospace; text-shadow: 0 0 5px var(--accent-color); }

        /* --- Game Area --- */
        #game-container {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }

        /* Overlays */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            padding: 30px;
            border-radius: 16px;
            border: 2px solid var(--accent-color);
            text-align: center;
            display: none;
            z-index: 20;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
        }

        #message-overlay h2 { margin-top: 0; color: var(--accent-color); }
        
        #start-btn {
            background: var(--accent-color);
            color: #000;
            border: none;
            padding: 12px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--accent-color);
        }

        .tutorial {
            position: absolute;
            top: 80px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: rgba(255,255,255,0.4);
            pointer-events: none;
        }

        /* --- Controls (New Layout) --- */
        #controls {
            height: 280px; /* Taller for better spacing */
            background: var(--panel-bg);
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            gap: 10px;
            z-index: 10;
            user-select: none;
            padding-bottom: max(20px, env(safe-area-inset-bottom)); /* iOS Home bar safe area */
        }

        .control-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }

        /* Center D-PAD */
        .d-pad-grid {
            display: grid;
            grid-template-columns: repeat(3, var(--dpad-size));
            grid-template-rows: repeat(3, var(--dpad-size));
            gap: 5px;
        }

        /* Button Styles */
        .btn {
            background: var(--btn-base);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 0 rgba(0,0,0,0.4);
            transition: all 0.1s;
            position: relative;
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(0,0,0,0.4);
            filter: brightness(1.2);
        }

        .btn svg { width: 24px; height: 24px; fill: currentColor; }

        /* D-Pad Specifics */
        .btn-up { grid-column: 2; grid-row: 1; background: #444466; border-radius: 10px 10px 4px 4px; }
        .btn-down { grid-column: 2; grid-row: 3; background: #444466; border-radius: 4px 4px 10px 10px;}
        .btn-left { grid-column: 1; grid-row: 2; background: #444466; border-radius: 10px 4px 4px 10px;}
        .btn-right { grid-column: 3; grid-row: 2; background: #444466; border-radius: 4px 10px 10px 4px;}
        .btn-cam { grid-column: 2; grid-row: 2; background: #222; font-size: 10px; border-radius: 50%; box-shadow: inset 0 0 5px #000; }

        /* Side Buttons */
        .side-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%; /* Round buttons for actions */
            flex-direction: column;
            font-size: 12px;
        }
        
        .side-btn span { margin-top: 4px; font-size: 10px; opacity: 0.8; }

        .btn-rotate-h { background: #9c27b0; } /* Purple */
        .btn-rotate-v { background: #e91e63; } /* Pink */
        .btn-soft { background: #2196f3; width: 60px; height: 60px; border-radius: 16px;} /* Blue */
        .btn-hard { background: #ff9800; width: 60px; height: 60px; border-radius: 16px;} /* Orange */

        @media (min-width: 768px) {
            body {
                max-width: 480px;
                margin: 0 auto;
                border-left: 1px solid #333;
                border-right: 1px solid #333;
            }
            #controls { height: 240px; }
        }
    </style>
</head>
<body>

    <div id="header">
        <div class="info-box">
            <div class="label">Score</div>
            <div class="value" id="score">0</div>
        </div>
        <div class="info-box">
            <div class="label">Lvl</div>
            <div class="value" id="level">1</div>
        </div>
        <div class="info-box">
            <div class="label">Next</div>
            <div class="value" id="next-piece-type">-</div>
        </div>
    </div>

    <div class="tutorial">Swipe screen to rotate camera</div>

    <div id="game-container">
        <div id="canvas-container"></div>
        <div id="message-overlay">
            <h2 id="msg-title">3D TETRIS</h2>
            <p id="msg-text">Vertical 5x5x12</p>
            <button id="start-btn">START</button>
        </div>
    </div>

    <!-- NEW LAYOUT -->
    <div id="controls">
        <!-- Left Column: Rotate H & Soft Drop -->
        <div class="control-column">
            <div class="btn side-btn btn-rotate-h" data-action="rotate-y">
                <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                <span>SPIN</span>
            </div>
            <div class="btn side-btn btn-soft" data-action="soft-drop">
                <svg viewBox="0 0 24 24"><path d="M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"/></svg>
            </div>
        </div>

        <!-- Center Column: D-PAD -->
        <div class="control-column">
            <div class="d-pad-grid">
                <div class="btn btn-up" data-action="move-back">▲</div>
                <div class="btn btn-left" data-action="move-left">◀</div>
                <div class="btn btn-cam" data-action="reset-cam">CAM</div>
                <div class="btn btn-right" data-action="move-right">▶</div>
                <div class="btn btn-down" data-action="move-front">▼</div>
            </div>
        </div>

        <!-- Right Column: Rotate V & Hard Drop -->
        <div class="control-column">
            <div class="btn side-btn btn-rotate-v" data-action="rotate-x">
                <svg viewBox="0 0 24 24" style="transform: rotate(90deg)"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
                <span>FLIP</span>
            </div>
            <div class="btn side-btn btn-hard" data-action="hard-drop">
                <svg viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
            </div>
        </div>
    </div>

<script>
/**
 * 3D TETRIS VERTICAL
 * Improved visibility & Layout
 */

const BOARD_W = 5;
const BOARD_D = 5;
const BOARD_H = 12;
const CUBE_SIZE = 1;
const BLOCK_SPACING = 0.05;

// Standard Tetris Colors (Brightened for visibility)
const TETROMINOS = {
    I: { color: 0x00FFFF, blocks: [[0,0,0], [-1,0,0], [1,0,0], [2,0,0]] }, // Cyan
    J: { color: 0x3333FF, blocks: [[0,0,0], [-1,0,0], [1,0,0], [-1,0,1]] }, // Blue
    L: { color: 0xFFAA00, blocks: [[0,0,0], [-1,0,0], [1,0,0], [1,0,1]] }, // Orange
    O: { color: 0xFFFF00, blocks: [[0,0,0], [1,0,0], [0,0,1], [1,0,1]] }, // Yellow
    S: { color: 0x00FF00, blocks: [[0,0,0], [1,0,0], [0,0,1], [-1,0,1]] }, // Green
    T: { color: 0xAA00FF, blocks: [[0,0,0], [-1,0,0], [1,0,0], [0,0,1]] }, // Purple
    Z: { color: 0xFF0000, blocks: [[0,0,0], [-1,0,0], [0,0,1], [1,0,1]] }  // Red
};

const SHAPE_KEYS = Object.keys(TETROMINOS);

let scene, camera, renderer;
let grid = [];
let activePiece = null;
let nextPieceType = null;
let gameInterval = null;
let isPaused = false;
let isGameOver = false;
let score = 0;
let level = 1;
let dropSpeed = 1000;

// Visual Groups
let boardGroup;
let activePieceGroup;
let ghostPieceGroup;
let placedBlocksGroup;

// Camera Controls
let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };
let cameraAngle = Math.PI / 4;
let cameraHeight = BOARD_H * 0.8;
let targetCameraAngle = Math.PI / 4;

function init() {
    const container = document.getElementById('canvas-container');

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050510, 0.02);

    camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
    updateCameraPosition();

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true; // Enable shadows for better depth
    container.appendChild(renderer.domElement);

    // Lighting - Increased brightness
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    
    // Backlight to see blocks clearly against dark background
    const backLight = new THREE.DirectionalLight(0x4444ff, 0.3);
    backLight.position.set(-10, 10, -10);
    scene.add(backLight);

    // Groups
    boardGroup = new THREE.Group();
    activePieceGroup = new THREE.Group();
    ghostPieceGroup = new THREE.Group();
    placedBlocksGroup = new THREE.Group();

    // Center offset
    const centeringOffset = new THREE.Vector3(-(BOARD_W-1)/2, 0, -(BOARD_D-1)/2);
    boardGroup.position.copy(centeringOffset);
    activePieceGroup.position.copy(centeringOffset);
    ghostPieceGroup.position.copy(centeringOffset);
    placedBlocksGroup.position.copy(centeringOffset);

    scene.add(boardGroup);
    scene.add(activePieceGroup);
    scene.add(ghostPieceGroup);
    scene.add(placedBlocksGroup);

    createBoardVisuals();
    initGrid();

    window.addEventListener('resize', onWindowResize, false);
    setupInputs();
    
    requestAnimationFrame(animate);
    
    document.getElementById('message-overlay').style.display = 'block';
    document.getElementById('start-btn').onclick = startGame;
}

function initGrid() {
    grid = [];
    for(let y=0; y<BOARD_H; y++) {
        grid[y] = [];
        for(let z=0; z<BOARD_D; z++) {
            grid[y][z] = [];
            for(let x=0; x<BOARD_W; x++) {
                grid[y][z][x] = null;
            }
        }
    }
}

function createBoardVisuals() {
    const totalW = BOARD_W * CUBE_SIZE;
    const totalH = BOARD_H * CUBE_SIZE;
    const totalD = BOARD_D * CUBE_SIZE;

    // Box Frame
    const geometry = new THREE.BoxGeometry(totalW, totalH, totalD);
    const edges = new THREE.EdgesGeometry(geometry);
    const material = new THREE.LineBasicMaterial({ color: 0x333366, transparent: true, opacity: 0.5 });
    const wireframe = new THREE.LineSegments(edges, material);
    wireframe.position.set((BOARD_W-1)/2, totalH/2 - 0.5, (BOARD_D-1)/2);
    boardGroup.add(wireframe);

    // Floor Grid
    const gridHelper = new THREE.GridHelper(BOARD_W, BOARD_W, 0x00f3ff, 0x111122);
    gridHelper.position.set((BOARD_W-1)/2, -0.5, (BOARD_D-1)/2);
    boardGroup.add(gridHelper);
}

function startGame() {
    document.getElementById('message-overlay').style.display = 'none';
    initGrid();
    
    while(placedBlocksGroup.children.length > 0){ 
        placedBlocksGroup.remove(placedBlocksGroup.children[0]); 
    }
    
    score = 0;
    level = 1;
    dropSpeed = 1000;
    isGameOver = false;
    isPaused = false;
    activePiece = null;
    
    updateScoreUI();
    spawnPiece();
    
    if(gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, dropSpeed);
}

function spawnPiece() {
    if (isGameOver) return;

    const type = nextPieceType || getRandomType();
    nextPieceType = getRandomType();
    document.getElementById('next-piece-type').innerText = nextPieceType;

    activePiece = {
        type: type,
        x: Math.floor(BOARD_W / 2),
        y: BOARD_H - 1,
        z: Math.floor(BOARD_D / 2),
        blocks: JSON.parse(JSON.stringify(TETROMINOS[type].blocks)),
        color: TETROMINOS[type].color
    };

    if (checkCollision(activePiece.x, activePiece.y, activePiece.z, activePiece.blocks)) {
        gameOver();
        return;
    }

    updateActivePieceVisual();
}

function getRandomType() {
    return SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)];
}

function gameLoop() {
    if (isPaused || isGameOver || !activePiece) return;
    movePiece(0, -1, 0);
}

function movePiece(dx, dy, dz) {
    if (!activePiece) return false;

    let adjDx = dx;
    let adjDz = dz;

    // Camera-relative movement logic
    if (dy === 0 && (dx !== 0 || dz !== 0)) {
        let angle = cameraAngle % (Math.PI * 2);
        if (angle < 0) angle += Math.PI * 2;
        const quarter = Math.round(angle / (Math.PI / 2)) % 4;
        
        if (quarter === 0) { adjDx = dx; adjDz = dz; }
        else if (quarter === 1) { adjDx = dz; adjDz = -dx; }
        else if (quarter === 2) { adjDx = -dx; adjDz = -dz; }
        else if (quarter === 3) { adjDx = -dz; adjDz = dx; }
    }

    if (!checkCollision(activePiece.x + adjDx, activePiece.y + dy, activePiece.z + adjDz, activePiece.blocks)) {
        activePiece.x += adjDx;
        activePiece.y += dy;
        activePiece.z += adjDz;
        updateActivePieceVisual();
        return true;
    } else {
        if (dy < 0) {
            lockPiece();
        }
        return false;
    }
}

function rotatePiece(axis) {
    if (!activePiece) return;

    const oldBlocks = activePiece.blocks;
    const newBlocks = activePiece.blocks.map(b => {
        let x = b[0], y = b[1], z = b[2];
        if (axis === 'y') return [-z, y, x];
        if (axis === 'x') return [x, -z, y];
        return [x, y, z];
    });

    // Simple Wall Kicks
    const kicks = [[0,0,0], [1,0,0], [-1,0,0], [0,0,1], [0,0,-1], [0,1,0], [0,2,0]];

    for (let k of kicks) {
        if (!checkCollision(activePiece.x + k[0], activePiece.y + k[1], activePiece.z + k[2], newBlocks)) {
            activePiece.x += k[0];
            activePiece.y += k[1];
            activePiece.z += k[2];
            activePiece.blocks = newBlocks;
            updateActivePieceVisual();
            return;
        }
    }
}

function hardDrop() {
    if(!activePiece) return;
    while (movePiece(0, -1, 0)) {
        score += 2;
    }
    updateScoreUI();
}

function checkCollision(px, py, pz, blocks) {
    for (let b of blocks) {
        let x = px + b[0];
        let y = py + b[1];
        let z = pz + b[2];
        if (x < 0 || x >= BOARD_W || z < 0 || z >= BOARD_D || y < 0) return true;
        if (y < BOARD_H && grid[y][z][x] !== null) return true;
    }
    return false;
}

function lockPiece() {
    for (let b of activePiece.blocks) {
        let x = activePiece.x + b[0];
        let y = activePiece.y + b[1];
        let z = activePiece.z + b[2];
        if (y >= 0 && y < BOARD_H) {
            grid[y][z][x] = activePiece.color;
            addStaticBlockVisual(x, y, z, activePiece.color);
        }
    }
    
    checkLines();
    
    // Temporarily disable activePiece to prevent input spam causing glitches
    activePiece = null;
    updateActivePieceVisual();

    // Small delay before next piece
    setTimeout(() => {
        if(!isGameOver) spawnPiece();
    }, 150);
}

function addStaticBlockVisual(x, y, z, color) {
    const mesh = createCubeMesh(color, 1.0, false);
    mesh.position.set(x, y, z);
    placedBlocksGroup.add(mesh);
}

function checkLines() {
    let linesCleared = 0;
    for (let y = 0; y < BOARD_H; y++) {
        let isFull = true;
        for (let z = 0; z < BOARD_D; z++) {
            for (let x = 0; x < BOARD_W; x++) {
                if (grid[y][z][x] === null) { isFull = false; break; }
            }
            if (!isFull) break;
        }
        if (isFull) {
            clearLayer(y);
            y--;
            linesCleared++;
        }
    }
    if (linesCleared > 0) {
        score += [0, 100, 300, 500, 800, 1200][linesCleared] * level;
        level = Math.floor(score / 5000) + 1;
        dropSpeed = Math.max(100, 1000 - (level - 1) * 100);
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, dropSpeed);
        updateScoreUI();
        rebuildBoardVisuals();
    }
}

function clearLayer(layerY) {
    for (let y = layerY; y < BOARD_H - 1; y++) {
        for (let z = 0; z < BOARD_D; z++) {
            for (let x = 0; x < BOARD_W; x++) {
                grid[y][z][x] = grid[y+1][z][x];
            }
        }
    }
    for (let z = 0; z < BOARD_D; z++) {
        for (let x = 0; x < BOARD_W; x++) {
            grid[BOARD_H-1][z][x] = null;
        }
    }
}

function rebuildBoardVisuals() {
    while(placedBlocksGroup.children.length > 0){ 
        placedBlocksGroup.remove(placedBlocksGroup.children[0]); 
    }
    for (let y = 0; y < BOARD_H; y++) {
        for (let z = 0; z < BOARD_D; z++) {
            for (let x = 0; x < BOARD_W; x++) {
                if (grid[y][z][x] !== null) {
                    addStaticBlockVisual(x, y, z, grid[y][z][x]);
                }
            }
        }
    }
}

function gameOver() {
    isGameOver = true;
    clearInterval(gameInterval);
    document.getElementById('msg-title').innerText = "GAME OVER";
    document.getElementById('msg-text').innerText = `Final Score: ${score}`;
    document.getElementById('start-btn').innerText = "RETRY";
    document.getElementById('message-overlay').style.display = 'block';
}

function updateScoreUI() {
    document.getElementById('score').innerText = score;
    document.getElementById('level').innerText = level;
}

// --- Visual Helpers ---

function createCubeMesh(color, opacity = 1.0, isGhost = false) {
    // Use slightly smaller size for gap
    const size = CUBE_SIZE - BLOCK_SPACING;
    const geometry = new THREE.BoxGeometry(size, size, size);
    
    let material;
    if (isGhost) {
        // Ghost: Wireframe-ish, low opacity
        material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.2,
            wireframe: true
        });
    } else {
        // Active/Static: Solid, nice lighting
        material = new THREE.MeshStandardMaterial({ 
            color: color, 
            emissive: color,
            emissiveIntensity: 0.4, // Glows
            transparent: true, 
            opacity: opacity,
            roughness: 0.1,
            metalness: 0.1
        });
    }
    
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add edge outline for better visibility
    if (!isGhost) {
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
        mesh.add(line);
    }
    
    return mesh;
}

function updateActivePieceVisual() {
    while(activePieceGroup.children.length > 0){ activePieceGroup.remove(activePieceGroup.children[0]); }
    while(ghostPieceGroup.children.length > 0){ ghostPieceGroup.remove(ghostPieceGroup.children[0]); }

    if(!activePiece) return;

    // GHOST
    let ghostY = activePiece.y;
    while (!checkCollision(activePiece.x, ghostY - 1, activePiece.z, activePiece.blocks)) {
        ghostY--;
    }
    
    for (let b of activePiece.blocks) {
        const mesh = createCubeMesh(activePiece.color, 1.0, true); // isGhost = true
        mesh.position.set(activePiece.x + b[0], ghostY + b[1], activePiece.z + b[2]);
        ghostPieceGroup.add(mesh);
    }

    // ACTIVE
    for (let b of activePiece.blocks) {
        const mesh = createCubeMesh(activePiece.color, 0.9, false); // isGhost = false
        mesh.position.set(activePiece.x + b[0], activePiece.y + b[1], activePiece.z + b[2]);
        activePieceGroup.add(mesh);
    }
}

function onWindowResize() {
    const container = document.getElementById('canvas-container');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

function updateCameraPosition() {
    const radius = 12;
    const x = Math.sin(cameraAngle) * radius;
    const z = Math.cos(cameraAngle) * radius;
    camera.position.set(x, cameraHeight, z);
    camera.lookAt(0, BOARD_H/3, 0);
}

function animate() {
    requestAnimationFrame(animate);
    if (Math.abs(cameraAngle - targetCameraAngle) > 0.001) {
        cameraAngle += (targetCameraAngle - cameraAngle) * 0.1;
        updateCameraPosition();
    }
    renderer.render(scene, camera);
}

function setupInputs() {
    document.addEventListener('keydown', (e) => {
        if(isGameOver) return;
        switch(e.code) {
            case 'ArrowUp': movePiece(0, 0, -1); break;
            case 'ArrowDown': movePiece(0, 0, 1); break;
            case 'ArrowLeft': movePiece(-1, 0, 0); break;
            case 'ArrowRight': movePiece(1, 0, 0); break;
            case 'Space': hardDrop(); break;
            case 'KeyZ': rotatePiece('y'); break;
            case 'KeyX': rotatePiece('x'); break;
        }
    });

    const container = document.getElementById('canvas-container');
    
    container.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.clientX - previousMousePosition.x;
        targetCameraAngle -= deltaX * 0.01;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('touchstart', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }, {passive: false});
    container.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        targetCameraAngle -= deltaX * 0.015;
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }, {passive: false});
    window.addEventListener('touchend', () => isDragging = false);

    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(btn => {
        const action = btn.dataset.action;
        
        // Support both touch and mouse without double firing
        const trigger = (e) => {
            e.preventDefault(); 
            if(isGameOver) return;

            switch(action) {
                case 'move-back': movePiece(0, 0, -1); break;
                case 'move-front': movePiece(0, 0, 1); break;
                case 'move-left': movePiece(-1, 0, 0); break;
                case 'move-right': movePiece(1, 0, 0); break;
                case 'rotate-y': rotatePiece('y'); break;
                case 'rotate-x': rotatePiece('x'); break;
                case 'soft-drop': movePiece(0, -1, 0); break;
                case 'hard-drop': hardDrop(); break;
                case 'reset-cam': targetCameraAngle = Math.PI / 4; break;
            }
        };

        btn.addEventListener('touchstart', trigger, {passive: false});
        btn.addEventListener('mousedown', trigger);
    });
}

init();

</script>
</body>
</html>