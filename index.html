<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Tetris Vertical</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-color: #050510;
            --panel-bg: rgba(20, 20, 35, 0.8);
            --accent-color: #00f3ff;
            --text-color: #e0f7fa;
            --btn-color: #2a2a40;
            --btn-active: #4a4a60;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent default touch actions like scroll */
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* --- Header / Info --- */
        #header {
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            z-index: 10;
            position: absolute;
            top: 0;
            width: 100%;
            box-sizing: border-box;
            pointer-events: none; /* Let touches pass through to canvas if needed */
        }

        .info-box {
            background: var(--panel-bg);
            padding: 5px 10px;
            border-radius: 8px;
            border: 1px solid rgba(0, 243, 255, 0.3);
            text-align: center;
            pointer-events: auto;
        }

        .label { font-size: 10px; color: #aaa; text-transform: uppercase; }
        .value { font-size: 18px; font-weight: bold; color: var(--accent-color); font-family: monospace; }

        /* --- Game Area --- */
        #game-container {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
        }

        /* Overlays */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid var(--accent-color);
            text-align: center;
            display: none;
            z-index: 20;
            backdrop-filter: blur(5px);
        }
        
        #start-btn {
            background: var(--accent-color);
            color: #000;
            border: none;
            padding: 10px 30px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }

        /* --- Controls --- */
        #controls {
            height: 260px; /* Mobile optimized height */
            background: var(--panel-bg);
            border-top: 2px solid rgba(0, 243, 255, 0.2);
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto;
            padding: 10px;
            gap: 10px;
            z-index: 10;
            user-select: none;
        }

        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            aspect-ratio: 1;
            max-width: 180px;
            margin: 0 auto;
        }

        .action-pad {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            max-width: 180px;
            margin: 0 auto;
        }

        .btn {
            background: var(--btn-color);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
            transition: transform 0.1s, box-shadow 0.1s;
            touch-action: manipulation;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(0,0,0,0.5);
            background: var(--btn-active);
        }

        .btn-center { grid-column: 2; grid-row: 2; background: #444; font-size: 12px; }
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-down { grid-column: 2; grid-row: 3; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-right { grid-column: 3; grid-row: 2; }

        .btn-rotate-h { background: #9c27b0; grid-column: 1; grid-row: 1; font-size: 14px; flex-direction: column;}
        .btn-rotate-v { background: #e91e63; grid-column: 2; grid-row: 1; font-size: 14px; flex-direction: column;}
        .btn-soft-drop { background: #2196f3; grid-column: 1; grid-row: 2; }
        .btn-hard-drop { background: #ff9800; grid-column: 2; grid-row: 2; }

        .btn span { display: block; font-size: 10px; opacity: 0.8; margin-top: 2px;}

        /* --- Tutorial / Hint --- */
        .tutorial {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
            width: 100%;
            text-align: center;
        }

        @media (min-width: 768px) {
            #controls {
                height: 180px;
                grid-template-columns: auto auto;
                justify-content: center;
                gap: 40px;
            }
            .d-pad, .action-pad {
                width: 160px;
            }
            body {
                max-width: 500px;
                margin: 0 auto;
                border-left: 1px solid #333;
                border-right: 1px solid #333;
            }
        }
    </style>
</head>
<body>

    <div id="header">
        <div class="info-box">
            <div class="label">Score</div>
            <div class="value" id="score">0</div>
        </div>
        <div class="info-box">
            <div class="label">Level</div>
            <div class="value" id="level">1</div>
        </div>
        <div class="info-box">
            <div class="label">Next</div>
            <!-- Simple canvas for Next piece could go here, text for now -->
            <div class="value" id="next-piece-type">-</div>
        </div>
    </div>

    <div class="tutorial">Drag screen to rotate camera</div>

    <div id="game-container">
        <div id="canvas-container"></div>
        <div id="message-overlay">
            <h2 id="msg-title">3D TETRIS</h2>
            <p id="msg-text">Vertical 5x5x12</p>
            <button id="start-btn">START GAME</button>
        </div>
    </div>

    <div id="controls">
        <!-- Movement -->
        <div class="d-pad">
            <div class="btn btn-up" data-action="move-back">▲</div>
            <div class="btn btn-left" data-action="move-left">◀</div>
            <div class="btn btn-center" data-action="reset-cam">CAM</div>
            <div class="btn btn-right" data-action="move-right">▶</div>
            <div class="btn btn-down" data-action="move-front">▼</div>
        </div>

        <!-- Actions -->
        <div class="action-pad">
            <div class="btn btn-rotate-h" data-action="rotate-y">⟳<span>SPIN</span></div>
            <div class="btn btn-rotate-v" data-action="rotate-x">⤹<span>FLIP</span></div>
            <div class="btn btn-soft-drop" data-action="soft-drop">↓↓</div>
            <div class="btn btn-hard-drop" data-action="hard-drop">⤓</div>
        </div>
    </div>

<script>
/**
 * 3D TETRIS VERTICAL
 * Logic and Rendering
 */

// --- Config ---
const BOARD_W = 5;
const BOARD_D = 5;
const BOARD_H = 12;
const CUBE_SIZE = 1;
const BLOCK_SPACING = 0.05; // Small gap for visual separation

// --- Tetromino Definitions (Shapes in 3D) ---
// Defines coordinates relative to center (0,0,0)
// Color format: Hex
const TETROMINOS = {
    I: { color: 0x00f0f0, blocks: [[0,0,0], [-1,0,0], [1,0,0], [2,0,0]] },
    J: { color: 0x0000f0, blocks: [[0,0,0], [-1,0,0], [1,0,0], [-1,0,1]] },
    L: { color: 0xf0a000, blocks: [[0,0,0], [-1,0,0], [1,0,0], [1,0,1]] },
    O: { color: 0xf0f000, blocks: [[0,0,0], [1,0,0], [0,0,1], [1,0,1]] }, // 2x2 flat
    S: { color: 0x00f000, blocks: [[0,0,0], [1,0,0], [0,0,1], [-1,0,1]] },
    T: { color: 0xa000f0, blocks: [[0,0,0], [-1,0,0], [1,0,0], [0,0,1]] },
    Z: { color: 0xf00000, blocks: [[0,0,0], [-1,0,0], [0,0,1], [1,0,1]] }
};

const SHAPE_KEYS = Object.keys(TETROMINOS);

// --- Global State ---
let scene, camera, renderer;
let grid = []; // 3D array [y][z][x] storing color or null
let activePiece = null;
let nextPieceType = null;
let gameInterval = null;
let isPaused = false;
let isGameOver = false;
let score = 0;
let level = 1;
let dropSpeed = 1000;

// Visual Groups
let boardGroup;
let activePieceGroup;
let ghostPieceGroup;
let placedBlocksGroup;

// Camera Controls
let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };
let cameraAngle = Math.PI / 4; // Start angle
let cameraHeight = BOARD_H * 0.8;
let targetCameraAngle = Math.PI / 4;

// --- Initialization ---
function init() {
    const container = document.getElementById('canvas-container');

    // Scene setup
    scene = new THREE.Scene();
    // Fog for depth perception
    scene.fog = new THREE.FogExp2(0x050510, 0.02);

    // Camera
    camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
    updateCameraPosition();

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    
    const pointLight = new THREE.PointLight(0x00f3ff, 0.5, 20);
    pointLight.position.set(0, 10, 0);
    scene.add(pointLight);

    // Groups
    boardGroup = new THREE.Group();
    activePieceGroup = new THREE.Group();
    ghostPieceGroup = new THREE.Group();
    placedBlocksGroup = new THREE.Group();

    // Adjust board position so (0,0,0) is bottom center
    // Our logical grid: x: 0..4, y: 0..11, z: 0..4
    // World center offset: x: -2, z: -2
    const centeringOffset = new THREE.Vector3(-(BOARD_W-1)/2, 0, -(BOARD_D-1)/2);
    
    boardGroup.position.copy(centeringOffset);
    activePieceGroup.position.copy(centeringOffset);
    ghostPieceGroup.position.copy(centeringOffset);
    placedBlocksGroup.position.copy(centeringOffset);

    scene.add(boardGroup);
    scene.add(activePieceGroup);
    scene.add(ghostPieceGroup);
    scene.add(placedBlocksGroup);

    createBoardVisuals();
    initGrid();

    // Event Listeners
    window.addEventListener('resize', onWindowResize, false);
    setupInputs();
    
    // Start Loop
    requestAnimationFrame(animate);
    
    // Show Menu
    document.getElementById('message-overlay').style.display = 'block';
    document.getElementById('start-btn').onclick = startGame;
}

function initGrid() {
    grid = [];
    for(let y=0; y<BOARD_H; y++) {
        grid[y] = [];
        for(let z=0; z<BOARD_D; z++) {
            grid[y][z] = [];
            for(let x=0; x<BOARD_W; x++) {
                grid[y][z][x] = null;
            }
        }
    }
}

function createBoardVisuals() {
    // Create the wireframe box container
    const totalW = BOARD_W * CUBE_SIZE;
    const totalH = BOARD_H * CUBE_SIZE;
    const totalD = BOARD_D * CUBE_SIZE;

    // Main bounding box
    const geometry = new THREE.BoxGeometry(totalW, totalH, totalD);
    const edges = new THREE.EdgesGeometry(geometry);
    const material = new THREE.LineBasicMaterial({ color: 0x4444ff, transparent: true, opacity: 0.3 });
    const wireframe = new THREE.LineSegments(edges, material);
    
    // Shift up because BoxGeometry is centered
    wireframe.position.set((BOARD_W-1)/2, totalH/2 - 0.5, (BOARD_D-1)/2);
    boardGroup.add(wireframe);

    // Grid Floor
    const gridHelper = new THREE.GridHelper(BOARD_W, BOARD_W, 0x222222, 0x111111);
    gridHelper.position.set((BOARD_W-1)/2, -0.5, (BOARD_D-1)/2);
    boardGroup.add(gridHelper);
}

// --- Game Logic ---

function startGame() {
    document.getElementById('message-overlay').style.display = 'none';
    initGrid();
    
    // Clear visuals
    while(placedBlocksGroup.children.length > 0){ 
        placedBlocksGroup.remove(placedBlocksGroup.children[0]); 
    }
    
    score = 0;
    level = 1;
    dropSpeed = 1000;
    isGameOver = false;
    isPaused = false;
    activePiece = null; // Reset active piece
    
    updateScoreUI();
    spawnPiece();
    
    if(gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, dropSpeed);
}

function spawnPiece() {
    // Safety check: if game is over, don't spawn
    if (isGameOver) return;

    const type = nextPieceType || getRandomType();
    nextPieceType = getRandomType();
    document.getElementById('next-piece-type').innerText = nextPieceType;

    activePiece = {
        type: type,
        x: Math.floor(BOARD_W / 2),
        y: BOARD_H - 1,
        z: Math.floor(BOARD_D / 2),
        blocks: JSON.parse(JSON.stringify(TETROMINOS[type].blocks)), // Deep copy
        color: TETROMINOS[type].color
    };

    // Check collision on spawn
    if (checkCollision(activePiece.x, activePiece.y, activePiece.z, activePiece.blocks)) {
        gameOver();
        return;
    }

    updateActivePieceVisual();
}

function getRandomType() {
    return SHAPE_KEYS[Math.floor(Math.random() * SHAPE_KEYS.length)];
}

function gameLoop() {
    if (isPaused || isGameOver) return;
    movePiece(0, -1, 0);
}

// dx, dy, dz are direction of movement
// returns true if moved successfully
function movePiece(dx, dy, dz) {
    if (!activePiece) return false;

    // Calculate absolute direction based on camera angle for X/Z inputs
    // If dy is 0 (horizontal movement), adjust dx/dz based on camera
    let adjDx = dx;
    let adjDz = dz;

    if (dy === 0 && (dx !== 0 || dz !== 0)) {
        // Simple 4-way camera adjustment
        // Normalize angle to 0-2PI
        let angle = cameraAngle % (Math.PI * 2);
        if (angle < 0) angle += Math.PI * 2;

        // Determine quadrant
        // 0 (front): z+ is forward(screen down), x+ is right
        // But we want controls: Up -> Z-, Down -> Z+, Left -> X-, Right -> X+ (Standard view)
        // We align controls to the camera view.
        
        // Simplify: Round angle to nearest 90 deg (PI/2)
        const quarter = Math.round(angle / (Math.PI / 2)) % 4;
        
        // Original input: 
        // Up(dz=-1), Down(dz=1), Left(dx=-1), Right(dx=1)
        
        // Transform input based on camera rotation
        // 0: No rotation
        // 1: 90 deg left
        // 2: 180 deg
        // 3: 270 deg (90 right)
        
        if (quarter === 0) { adjDx = dx; adjDz = dz; }
        else if (quarter === 1) { adjDx = dz; adjDz = -dx; } // Rotated 90 deg
        else if (quarter === 2) { adjDx = -dx; adjDz = -dz; } // Rotated 180
        else if (quarter === 3) { adjDx = -dz; adjDz = dx; } // Rotated 270
    }

    if (!checkCollision(activePiece.x + adjDx, activePiece.y + dy, activePiece.z + adjDz, activePiece.blocks)) {
        activePiece.x += adjDx;
        activePiece.y += dy;
        activePiece.z += adjDz;
        updateActivePieceVisual();
        return true;
    } else {
        // Collision detected
        if (dy < 0) {
            // Hit bottom or block below
            lockPiece();
        }
        return false;
    }
}

// Axis: 'y' (spin), 'x' (flip), 'z' (roll)
function rotatePiece(axis) {
    if (!activePiece) return;

    const oldBlocks = activePiece.blocks;
    const newBlocks = activePiece.blocks.map(b => {
        let x = b[0], y = b[1], z = b[2];
        // 90 degree rotation matrix logic simplified
        if (axis === 'y') return [-z, y, x]; // Yaw
        if (axis === 'x') return [x, -z, y]; // Pitch/Flip
        if (axis === 'z') return [-y, x, z]; // Roll
        return [x, y, z];
    });

    // Wall kick - simple tries
    // Try center, then offsets
    const kicks = [
        [0,0,0], [1,0,0], [-1,0,0], [0,0,1], [0,0,-1], // Horizontal
        [0,1,0], [0,2,0] // Upward (floor kick)
    ];

    for (let k of kicks) {
        if (!checkCollision(activePiece.x + k[0], activePiece.y + k[1], activePiece.z + k[2], newBlocks)) {
            activePiece.x += k[0];
            activePiece.y += k[1];
            activePiece.z += k[2];
            activePiece.blocks = newBlocks;
            updateActivePieceVisual();
            return;
        }
    }
}

function hardDrop() {
    if(!activePiece) return;
    // Loop until movePiece returns false (collision)
    while (movePiece(0, -1, 0)) {
        score += 2; // Bonus for hard drop
    }
    updateScoreUI();
}

function checkCollision(px, py, pz, blocks) {
    for (let b of blocks) {
        let x = px + b[0];
        let y = py + b[1];
        let z = pz + b[2];

        // Bounds check
        if (x < 0 || x >= BOARD_W || z < 0 || z >= BOARD_D || y < 0) return true;
        
        // Grid check
        if (y < BOARD_H && grid[y][z][x] !== null) return true;
    }
    return false;
}

function lockPiece() {
    // Add to grid
    for (let b of activePiece.blocks) {
        let x = activePiece.x + b[0];
        let y = activePiece.y + b[1];
        let z = activePiece.z + b[2];
        
        if (y >= 0 && y < BOARD_H) { // Should always be true unless game over
            grid[y][z][x] = activePiece.color;
            addStaticBlockVisual(x, y, z, activePiece.color);
        }
    }
    
    // 1. Check for lines to clear
    checkLines();

    // 2. Disable active piece immediately to prevent double inputs
    activePiece = null;
    updateActivePieceVisual(); // Clears the active/ghost mesh

    // 3. Spawn next piece with a small delay
    // This prevents accidental hard-drops on the new piece
    setTimeout(() => {
        if (!isGameOver) {
            spawnPiece();
        }
    }, 200);
}

function addStaticBlockVisual(x, y, z, color) {
    const mesh = createCubeMesh(color, 0.9);
    mesh.position.set(x, y, z);
    placedBlocksGroup.add(mesh);
    // Store reference in user data if needed for removal
    mesh.userData = { x, y, z };
}

function checkLines() {
    let linesCleared = 0;
    
    // Check each layer from bottom up
    for (let y = 0; y < BOARD_H; y++) {
        let isFull = true;
        for (let z = 0; z < BOARD_D; z++) {
            for (let x = 0; x < BOARD_W; x++) {
                if (grid[y][z][x] === null) {
                    isFull = false;
                    break;
                }
            }
            if (!isFull) break;
        }

        if (isFull) {
            clearLayer(y);
            y--; // Re-check this index as blocks fell down
            linesCleared++;
        }
    }

    if (linesCleared > 0) {
        score += [0, 100, 300, 500, 800, 1200][linesCleared] * level; // Classic scoring approx
        // Level up every 5000 points
        level = Math.floor(score / 5000) + 1;
        dropSpeed = Math.max(100, 1000 - (level - 1) * 100);
        
        // Update interval
        clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, dropSpeed);
        
        updateScoreUI();
        rebuildBoardVisuals();
    }
}

function clearLayer(layerY) {
    // Shift logical grid
    for (let y = layerY; y < BOARD_H - 1; y++) {
        for (let z = 0; z < BOARD_D; z++) {
            for (let x = 0; x < BOARD_W; x++) {
                grid[y][z][x] = grid[y+1][z][x];
            }
        }
    }
    // Clear top layer
    for (let z = 0; z < BOARD_D; z++) {
        for (let x = 0; x < BOARD_W; x++) {
            grid[BOARD_H-1][z][x] = null;
        }
    }
}

function rebuildBoardVisuals() {
    // Clear all static blocks and redraw
    while(placedBlocksGroup.children.length > 0){ 
        placedBlocksGroup.remove(placedBlocksGroup.children[0]); 
    }

    for (let y = 0; y < BOARD_H; y++) {
        for (let z = 0; z < BOARD_D; z++) {
            for (let x = 0; x < BOARD_W; x++) {
                if (grid[y][z][x] !== null) {
                    addStaticBlockVisual(x, y, z, grid[y][z][x]);
                }
            }
        }
    }
}

function gameOver() {
    isGameOver = true;
    clearInterval(gameInterval);
    document.getElementById('msg-title').innerText = "GAME OVER";
    document.getElementById('msg-text').innerText = `Final Score: ${score}`;
    document.getElementById('start-btn').innerText = "RETRY";
    document.getElementById('message-overlay').style.display = 'block';
}

function updateScoreUI() {
    document.getElementById('score').innerText = score;
    document.getElementById('level').innerText = level;
}

// --- Rendering Helpers ---

function createCubeMesh(color, opacity = 1.0) {
    const geometry = new THREE.BoxGeometry(CUBE_SIZE - BLOCK_SPACING, CUBE_SIZE - BLOCK_SPACING, CUBE_SIZE - BLOCK_SPACING);
    const material = new THREE.MeshLambertMaterial({ 
        color: color, 
        transparent: true, 
        opacity: opacity < 1 ? opacity : 0.9
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add edges for visibility
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
    mesh.add(line);
    
    return mesh;
}

function updateActivePieceVisual() {
    // Clear previous
    while(activePieceGroup.children.length > 0){ activePieceGroup.remove(activePieceGroup.children[0]); }
    while(ghostPieceGroup.children.length > 0){ ghostPieceGroup.remove(ghostPieceGroup.children[0]); }

    if(!activePiece) return;

    // Draw Ghost
    let ghostY = activePiece.y;
    while (!checkCollision(activePiece.x, ghostY - 1, activePiece.z, activePiece.blocks)) {
        ghostY--;
    }
    
    // Ghost Meshes
    for (let b of activePiece.blocks) {
        const mesh = createCubeMesh(activePiece.color, 0.3);
        mesh.position.set(activePiece.x + b[0], ghostY + b[1], activePiece.z + b[2]);
        // Make ghost look like wireframe only
        mesh.material.opacity = 0.1;
        mesh.material.emissive = activePiece.color;
        ghostPieceGroup.add(mesh);
    }

    // Draw Active
    for (let b of activePiece.blocks) {
        const mesh = createCubeMesh(activePiece.color, 1.0);
        mesh.position.set(activePiece.x + b[0], activePiece.y + b[1], activePiece.z + b[2]);
        mesh.material.emissive = 0x222222; // slight glow
        activePieceGroup.add(mesh);
    }
}

// --- Camera & Interaction ---

function onWindowResize() {
    const container = document.getElementById('canvas-container');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

function updateCameraPosition() {
    // Smooth rotation logic
    const radius = 12;
    const x = Math.sin(cameraAngle) * radius;
    const z = Math.cos(cameraAngle) * radius;
    
    camera.position.set(x, cameraHeight, z);
    camera.lookAt(0, BOARD_H/3, 0); // Look at lower center of board
}

function animate() {
    requestAnimationFrame(animate);
    
    // Smooth camera
    if (Math.abs(cameraAngle - targetCameraAngle) > 0.001) {
        cameraAngle += (targetCameraAngle - cameraAngle) * 0.1;
        updateCameraPosition();
    }
    
    renderer.render(scene, camera);
}

// Inputs
function setupInputs() {
    // Keyboard
    document.addEventListener('keydown', (e) => {
        if(isGameOver) return;
        
        switch(e.code) {
            case 'ArrowUp': movePiece(0, 0, -1); break;
            case 'ArrowDown': movePiece(0, 0, 1); break;
            case 'ArrowLeft': movePiece(-1, 0, 0); break;
            case 'ArrowRight': movePiece(1, 0, 0); break;
            case 'Space': hardDrop(); break;
            case 'KeyZ': rotatePiece('y'); break;
            case 'KeyX': rotatePiece('x'); break;
        }
    });

    // Touch / Mouse Drag for Camera
    const container = document.getElementById('canvas-container');
    
    container.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    
    window.addEventListener('mouseup', () => isDragging = false);
    
    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.clientX - previousMousePosition.x;
        targetCameraAngle -= deltaX * 0.01;
        previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    // Touch support for camera
    container.addEventListener('touchstart', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }, {passive: false});

    container.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        targetCameraAngle -= deltaX * 0.015; // Faster on touch
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }, {passive: false});
    
    window.addEventListener('touchend', () => isDragging = false);

    // On-screen Buttons
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(btn => {
        const action = btn.dataset.action;
        
        const trigger = (e) => {
            e.preventDefault(); // Stop ghost clicks
            if(isGameOver && action !== 'hard-drop') return; // Allow retry if logic added? No, start btn is separate

            switch(action) {
                case 'move-back': movePiece(0, 0, -1); break;
                case 'move-front': movePiece(0, 0, 1); break;
                case 'move-left': movePiece(-1, 0, 0); break;
                case 'move-right': movePiece(1, 0, 0); break;
                case 'rotate-y': rotatePiece('y'); break;
                case 'rotate-x': rotatePiece('x'); break;
                case 'soft-drop': movePiece(0, -1, 0); break;
                case 'hard-drop': hardDrop(); break;
                case 'reset-cam': targetCameraAngle = Math.PI / 4; break;
            }
        };

        btn.addEventListener('mousedown', trigger);
        btn.addEventListener('touchstart', trigger, {passive: false});
    });
}

// Start
init();

</script>
</body>
</html>